// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'main_categories_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MainCategoriesStateTearOff {
  const _$MainCategoriesStateTearOff();

  Idle idle() {
    return const Idle();
  }

  CategoriesLoading categoriesLoading() {
    return const CategoriesLoading();
  }

  CategoriesLoaded categoriesLoaded(List<MainCategoryModel> mainCategories) {
    return CategoriesLoaded(
      mainCategories,
    );
  }

  MainCategorySelected mainCategorySelected(
      MainCategoryModel mainCategoryModel) {
    return MainCategorySelected(
      mainCategoryModel,
    );
  }

  SubCategorySelected subCategorySelected(SubCategoryModel subCategoryModel) {
    return SubCategorySelected(
      subCategoryModel,
    );
  }

  Error error(String error) {
    return Error(
      error,
    );
  }
}

/// @nodoc
const $MainCategoriesState = _$MainCategoriesStateTearOff();

/// @nodoc
mixin _$MainCategoriesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainCategoriesStateCopyWith<$Res> {
  factory $MainCategoriesStateCopyWith(
          MainCategoriesState value, $Res Function(MainCategoriesState) then) =
      _$MainCategoriesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$MainCategoriesStateCopyWithImpl<$Res>
    implements $MainCategoriesStateCopyWith<$Res> {
  _$MainCategoriesStateCopyWithImpl(this._value, this._then);

  final MainCategoriesState _value;
  // ignore: unused_field
  final $Res Function(MainCategoriesState) _then;
}

/// @nodoc
abstract class $IdleCopyWith<$Res> {
  factory $IdleCopyWith(Idle value, $Res Function(Idle) then) =
      _$IdleCopyWithImpl<$Res>;
}

/// @nodoc
class _$IdleCopyWithImpl<$Res> extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $IdleCopyWith<$Res> {
  _$IdleCopyWithImpl(Idle _value, $Res Function(Idle) _then)
      : super(_value, (v) => _then(v as Idle));

  @override
  Idle get _value => super._value as Idle;
}

/// @nodoc

class _$Idle implements Idle {
  const _$Idle();

  @override
  String toString() {
    return 'MainCategoriesState.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Idle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class Idle implements MainCategoriesState {
  const factory Idle() = _$Idle;
}

/// @nodoc
abstract class $CategoriesLoadingCopyWith<$Res> {
  factory $CategoriesLoadingCopyWith(
          CategoriesLoading value, $Res Function(CategoriesLoading) then) =
      _$CategoriesLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$CategoriesLoadingCopyWithImpl<$Res>
    extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $CategoriesLoadingCopyWith<$Res> {
  _$CategoriesLoadingCopyWithImpl(
      CategoriesLoading _value, $Res Function(CategoriesLoading) _then)
      : super(_value, (v) => _then(v as CategoriesLoading));

  @override
  CategoriesLoading get _value => super._value as CategoriesLoading;
}

/// @nodoc

class _$CategoriesLoading implements CategoriesLoading {
  const _$CategoriesLoading();

  @override
  String toString() {
    return 'MainCategoriesState.categoriesLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CategoriesLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return categoriesLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return categoriesLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (categoriesLoading != null) {
      return categoriesLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return categoriesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return categoriesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (categoriesLoading != null) {
      return categoriesLoading(this);
    }
    return orElse();
  }
}

abstract class CategoriesLoading implements MainCategoriesState {
  const factory CategoriesLoading() = _$CategoriesLoading;
}

/// @nodoc
abstract class $CategoriesLoadedCopyWith<$Res> {
  factory $CategoriesLoadedCopyWith(
          CategoriesLoaded value, $Res Function(CategoriesLoaded) then) =
      _$CategoriesLoadedCopyWithImpl<$Res>;
  $Res call({List<MainCategoryModel> mainCategories});
}

/// @nodoc
class _$CategoriesLoadedCopyWithImpl<$Res>
    extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $CategoriesLoadedCopyWith<$Res> {
  _$CategoriesLoadedCopyWithImpl(
      CategoriesLoaded _value, $Res Function(CategoriesLoaded) _then)
      : super(_value, (v) => _then(v as CategoriesLoaded));

  @override
  CategoriesLoaded get _value => super._value as CategoriesLoaded;

  @override
  $Res call({
    Object? mainCategories = freezed,
  }) {
    return _then(CategoriesLoaded(
      mainCategories == freezed
          ? _value.mainCategories
          : mainCategories // ignore: cast_nullable_to_non_nullable
              as List<MainCategoryModel>,
    ));
  }
}

/// @nodoc

class _$CategoriesLoaded implements CategoriesLoaded {
  const _$CategoriesLoaded(this.mainCategories);

  @override
  final List<MainCategoryModel> mainCategories;

  @override
  String toString() {
    return 'MainCategoriesState.categoriesLoaded(mainCategories: $mainCategories)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoriesLoaded &&
            (identical(other.mainCategories, mainCategories) ||
                const DeepCollectionEquality()
                    .equals(other.mainCategories, mainCategories)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(mainCategories);

  @JsonKey(ignore: true)
  @override
  $CategoriesLoadedCopyWith<CategoriesLoaded> get copyWith =>
      _$CategoriesLoadedCopyWithImpl<CategoriesLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return categoriesLoaded(mainCategories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return categoriesLoaded?.call(mainCategories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (categoriesLoaded != null) {
      return categoriesLoaded(mainCategories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return categoriesLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return categoriesLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (categoriesLoaded != null) {
      return categoriesLoaded(this);
    }
    return orElse();
  }
}

abstract class CategoriesLoaded implements MainCategoriesState {
  const factory CategoriesLoaded(List<MainCategoryModel> mainCategories) =
      _$CategoriesLoaded;

  List<MainCategoryModel> get mainCategories =>
      throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CategoriesLoadedCopyWith<CategoriesLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainCategorySelectedCopyWith<$Res> {
  factory $MainCategorySelectedCopyWith(MainCategorySelected value,
          $Res Function(MainCategorySelected) then) =
      _$MainCategorySelectedCopyWithImpl<$Res>;
  $Res call({MainCategoryModel mainCategoryModel});
}

/// @nodoc
class _$MainCategorySelectedCopyWithImpl<$Res>
    extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $MainCategorySelectedCopyWith<$Res> {
  _$MainCategorySelectedCopyWithImpl(
      MainCategorySelected _value, $Res Function(MainCategorySelected) _then)
      : super(_value, (v) => _then(v as MainCategorySelected));

  @override
  MainCategorySelected get _value => super._value as MainCategorySelected;

  @override
  $Res call({
    Object? mainCategoryModel = freezed,
  }) {
    return _then(MainCategorySelected(
      mainCategoryModel == freezed
          ? _value.mainCategoryModel
          : mainCategoryModel // ignore: cast_nullable_to_non_nullable
              as MainCategoryModel,
    ));
  }
}

/// @nodoc

class _$MainCategorySelected implements MainCategorySelected {
  const _$MainCategorySelected(this.mainCategoryModel);

  @override
  final MainCategoryModel mainCategoryModel;

  @override
  String toString() {
    return 'MainCategoriesState.mainCategorySelected(mainCategoryModel: $mainCategoryModel)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MainCategorySelected &&
            (identical(other.mainCategoryModel, mainCategoryModel) ||
                const DeepCollectionEquality()
                    .equals(other.mainCategoryModel, mainCategoryModel)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(mainCategoryModel);

  @JsonKey(ignore: true)
  @override
  $MainCategorySelectedCopyWith<MainCategorySelected> get copyWith =>
      _$MainCategorySelectedCopyWithImpl<MainCategorySelected>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return mainCategorySelected(mainCategoryModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return mainCategorySelected?.call(mainCategoryModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (mainCategorySelected != null) {
      return mainCategorySelected(mainCategoryModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return mainCategorySelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return mainCategorySelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (mainCategorySelected != null) {
      return mainCategorySelected(this);
    }
    return orElse();
  }
}

abstract class MainCategorySelected implements MainCategoriesState {
  const factory MainCategorySelected(MainCategoryModel mainCategoryModel) =
      _$MainCategorySelected;

  MainCategoryModel get mainCategoryModel => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MainCategorySelectedCopyWith<MainCategorySelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubCategorySelectedCopyWith<$Res> {
  factory $SubCategorySelectedCopyWith(
          SubCategorySelected value, $Res Function(SubCategorySelected) then) =
      _$SubCategorySelectedCopyWithImpl<$Res>;
  $Res call({SubCategoryModel subCategoryModel});
}

/// @nodoc
class _$SubCategorySelectedCopyWithImpl<$Res>
    extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $SubCategorySelectedCopyWith<$Res> {
  _$SubCategorySelectedCopyWithImpl(
      SubCategorySelected _value, $Res Function(SubCategorySelected) _then)
      : super(_value, (v) => _then(v as SubCategorySelected));

  @override
  SubCategorySelected get _value => super._value as SubCategorySelected;

  @override
  $Res call({
    Object? subCategoryModel = freezed,
  }) {
    return _then(SubCategorySelected(
      subCategoryModel == freezed
          ? _value.subCategoryModel
          : subCategoryModel // ignore: cast_nullable_to_non_nullable
              as SubCategoryModel,
    ));
  }
}

/// @nodoc

class _$SubCategorySelected implements SubCategorySelected {
  const _$SubCategorySelected(this.subCategoryModel);

  @override
  final SubCategoryModel subCategoryModel;

  @override
  String toString() {
    return 'MainCategoriesState.subCategorySelected(subCategoryModel: $subCategoryModel)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SubCategorySelected &&
            (identical(other.subCategoryModel, subCategoryModel) ||
                const DeepCollectionEquality()
                    .equals(other.subCategoryModel, subCategoryModel)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(subCategoryModel);

  @JsonKey(ignore: true)
  @override
  $SubCategorySelectedCopyWith<SubCategorySelected> get copyWith =>
      _$SubCategorySelectedCopyWithImpl<SubCategorySelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return subCategorySelected(subCategoryModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return subCategorySelected?.call(subCategoryModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (subCategorySelected != null) {
      return subCategorySelected(subCategoryModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return subCategorySelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return subCategorySelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (subCategorySelected != null) {
      return subCategorySelected(this);
    }
    return orElse();
  }
}

abstract class SubCategorySelected implements MainCategoriesState {
  const factory SubCategorySelected(SubCategoryModel subCategoryModel) =
      _$SubCategorySelected;

  SubCategoryModel get subCategoryModel => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubCategorySelectedCopyWith<SubCategorySelected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorCopyWith<$Res> {
  factory $ErrorCopyWith(Error value, $Res Function(Error) then) =
      _$ErrorCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class _$ErrorCopyWithImpl<$Res> extends _$MainCategoriesStateCopyWithImpl<$Res>
    implements $ErrorCopyWith<$Res> {
  _$ErrorCopyWithImpl(Error _value, $Res Function(Error) _then)
      : super(_value, (v) => _then(v as Error));

  @override
  Error get _value => super._value as Error;

  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(Error(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Error implements Error {
  const _$Error(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'MainCategoriesState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Error &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(error);

  @JsonKey(ignore: true)
  @override
  $ErrorCopyWith<Error> get copyWith =>
      _$ErrorCopyWithImpl<Error>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() categoriesLoading,
    required TResult Function(List<MainCategoryModel> mainCategories)
        categoriesLoaded,
    required TResult Function(MainCategoryModel mainCategoryModel)
        mainCategorySelected,
    required TResult Function(SubCategoryModel subCategoryModel)
        subCategorySelected,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? categoriesLoading,
    TResult Function(List<MainCategoryModel> mainCategories)? categoriesLoaded,
    TResult Function(MainCategoryModel mainCategoryModel)? mainCategorySelected,
    TResult Function(SubCategoryModel subCategoryModel)? subCategorySelected,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle value) idle,
    required TResult Function(CategoriesLoading value) categoriesLoading,
    required TResult Function(CategoriesLoaded value) categoriesLoaded,
    required TResult Function(MainCategorySelected value) mainCategorySelected,
    required TResult Function(SubCategorySelected value) subCategorySelected,
    required TResult Function(Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle value)? idle,
    TResult Function(CategoriesLoading value)? categoriesLoading,
    TResult Function(CategoriesLoaded value)? categoriesLoaded,
    TResult Function(MainCategorySelected value)? mainCategorySelected,
    TResult Function(SubCategorySelected value)? subCategorySelected,
    TResult Function(Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class Error implements MainCategoriesState {
  const factory Error(String error) = _$Error;

  String get error => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ErrorCopyWith<Error> get copyWith => throw _privateConstructorUsedError;
}
